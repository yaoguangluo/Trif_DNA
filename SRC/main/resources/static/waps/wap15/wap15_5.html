<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    <link rel="icon" href="../images/logo/logo.png" type="image/x-icon">
    <link rel="shortcut icon" href="../images/logo/logo.png"
          type="image/x-icon">
    <title>浏阳德塔软件开发有限公司 女娲计划</title>
</head>
<body style="Max-width: 700px; text-align:center; margin:auto;">
<div style="text-align:left; Max-width: 680px; margin-left:15px;">
    <a href="../">上一页</a>
    <br/>
    <br/>
    <br/>第十五章_元基模拟染色体新陈代谢催化编码
    <br/> 作者: 罗瑶光, Author:Yaoguang.Luo<br/>
    <br/>

    <br/>二次元基新陈代谢方式的图片描述

    <br/>
    <br/>首先处理一个函数,用java文件举例,我们有5个原文件,分别是,增加一个数据.java;删除一个
    数据.java;查看一个数据.java;感知并删除一个数据.java;感知并增加一个数据.java.
    这5个函数,首先我们进行第一步,肽化它. 于是变成: IS.java; DS.java; QS.java; VDS.java;
    VIS.java. 肽化的语法依据是(I, D, U, Q- 增加,删除,改变,查看; V, E, C, S- 感知,执行,控制,静态).
    于是开始进行相似相同元基片段归纳,分为2组(IS.java; DS.java; QS.java;), (VDS.java;
    VIS.java).
    <br/>
    <br/>
    <br/>
    <br/>于是开始细化文件中的函数分析. 假设 VIS.java文件中有4个函数,
    (增加一个感知的触发();增加一个感知的探索();增加一个感知的控制();增加一个感知的分析();)
    于是开始肽化函数为(IVT(); IVX(); IVC(); IVA();) 肽化的语法依据是(T, X, H, F- 触发
    ,探索,总,全). 新陈代谢便开始了. 首先先拆分. VIS.java+ IVT(); = SVI.java +XCDX+IVT()
    , 以此类推.
    <br/>
    <br/>当然,没有完,如果此时出现了新的条件,如 在T() 的函数中含有分析触发逻辑 T()--AT
    sections, 在 X()的函数中含有分析执行探索逻辑X()--AEX sections, 那么 文件名索引
    肽化又可以延展为(VIS.java+ IVT(); = SVI.java +XCDX+IVT() = SVI.java+ XCDX
    + IVT()+ XCDX+ AT())依次类推 不断的细化肽化索引. 上面VIS 和 SVI 可逆, 依据是
    VIS= VI+ S = S+ VI.
    <br/>
    <br/>最后,如果此时的函数中含有执行逻辑,如X()函数则可以CE分离,如下
    <br/>
    <br/>VIS.java+ IVX(); = SVI.java+ XCDX+ IVX()= SVI.java+ XCDX+ IVX()+
    XCDX+ AEX()+｛E, C｝
    <br/>
    <br/>然后再缩进过滤. 分别为: SVI+ IV+ AX() +E, SVI+ IV+ AX()+ C
    <br/>
    <br/>作者 罗瑶光 稍后优化逻辑
    <br/>
    <br/>An implementation of Secondary Metabolism about Meta Initons.
    <br/>
    <br/>At first, assume I have five ordinary java files, for samples are
    IncreaseData.java; DeleteData.java; CheckData.java;
    VisonaryIncreaseData.java; VisonaryDeleteData.java; I should make a
    translation of whom from humanoid lexical to DNA meta Initons. Base of
    the PDN Encoding grammar: (I, D, U, Q- Increment, Decrement, Upgrade,
    Query; V, E, C, S- Vision, Execute, Control, Static), the ordinary
    files will change into (IS.java; DS.java; QS.java;), (VDS.java;
    VIS.java).
    <br/>
    <br/>Then I can do the next step of definition. Assume VIS.java file
    contains four function prototypes as (IncreateVinsionaryTrigger ();
    IncreateVisionaryXplore (); IncreateVisionaryController ();
    IncreateVisionaryAnalysis (); I can make a translation of whom from
    humanoid lexical to DNA meta Initons as (IVT(); IVX(); IVC(); IVA();)
    Base of the PDN Encoding grammar: (T,X,H,F- Trigger, Xplore, Hall,
    Full). The metabolism starts. I can prove VIS.java+ IVT(); = SVI.java +
    XCDX+ IVT(), at here, VIS= VI+ S= S+ VI.
    <br/>
    <br/>It looks like a blooming Dandelion flower. At this time, assume a
    new condition has happened here, the T() contains logic of
    Analysis-Trigger, T()--AT sections. And X() contains logics of
    Analysis-Execute-Xplore, X()--AEX sections. Then the indexed DNA name
    could make a continuing PDE metabolism as below. (VIS.java+ IVT(); =
    SVI.java + XCDX+ IVT()= SVI.java + XCDX+ IVT() + XCDX+ AT())
    <br/>
    <br/>The final Assumption, if the X() also contains logic of
    Controller-Execute, then I make a CE separation of metabolism as below:
    VIS.java+ IVX(); = SVI.java+ XCDX+ IVX()= SVI.java+ XCDX+ IVX()+ XCDX+
    AEX()+｛E, C｝, then prove out SVI+ IV+ AX()+ E, SVI+ IV+ AX()+ C.
    <br/>
    <br/>The author YaoguangLuo 稍后优化语法结构.


    <br/>

</div>
</body>
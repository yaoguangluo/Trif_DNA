package S_A.SEM.bloom;

import java.io.IOException;

import ME.VPC.M.app.App;
import S_A.SEM.reflection.StaticReflectionMapA_IDUQ_C;
import S_A.SEM.reflection.StaticReflectionMapA_VECS_C;
import S_A.SEM.reflection.StaticReflectionMapC_AOPM_C;
import S_A.SEM.reflection.StaticReflectionMapC_IDUQ_C;
import S_A.SEM.reflection.StaticReflectionMapD_AOPM_C;
import S_A.SEM.reflection.StaticReflectionMapD_VECS_C;
import S_A.SEM.reflection.StaticReflectionMapE_AOPM_C;
import S_A.SEM.reflection.StaticReflectionMapE_IDUQ_C;
import S_A.SEM.reflection.StaticReflectionMapI_AOPM_C;
import S_A.SEM.reflection.StaticReflectionMapI_VECS_C;
import S_A.SEM.reflection.StaticReflectionMapM_IDUQ_C;
import S_A.SEM.reflection.StaticReflectionMapM_VECS_C;
import S_A.SEM.reflection.StaticReflectionMapO_IDUQ_C;
import S_A.SEM.reflection.StaticReflectionMapO_VECS_C;
import S_A.SEM.reflection.StaticReflectionMapP_IDUQ_C;
import S_A.SEM.reflection.StaticReflectionMapP_VECS_C;
import S_A.SEM.reflection.StaticReflectionMapQ_AOPM_C;
import S_A.SEM.reflection.StaticReflectionMapQ_VECS_C;
import S_A.SEM.reflection.StaticReflectionMapS_AOPM_C;
import S_A.SEM.reflection.StaticReflectionMapS_IDUQ_C;
import S_A.SEM.reflection.StaticReflectionMapU_AOPM_C;
import S_A.SEM.reflection.StaticReflectionMapU_VECS_C;
import S_A.SEM.reflection.StaticReflectionMapV_AOPM_C;
import S_A.SEM.reflection.StaticReflectionMapV_IDUQ_C;
import S_A.pheromone.IMV_SIQ;

//用来索引函数 注册类
//罗瑶光
/*
 * 著作权人 ，作者 罗瑶光, 浏阳
 * yaoguangluo@outlook.com, 313699483@qq.com, 2080315360@qq.com, -
 ** 15116110525-
 * 430181198505250014, G24402609, EB0581342
 * 204925063, 389418686, F2406501, 0626136
 * 湖南省 浏阳市 集里街道 神仙坳社区 大塘冲路一段
*  208号 阳光家园别墅小区 第十栋
 * */
public class StaticFunctionMap {
	public static void doA_VECS_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapA_VECS_E staticFunctionMapA_VECS_C,
			IMV_SIQ output, App NE) {
		if (callFunctionKey.contains("main", NE)) {
			// ....
		}
		StaticReflectionMapA_VECS_C.callFunction(callFunctionKey,
				staticFunctionMapA_VECS_C, output, NE);
	}

	public static void doA_IDUQ_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapA_IDUQ_E staticFunctionMapA_IDUQ_C,
			IMV_SIQ output, App NE) {
		StaticReflectionMapA_IDUQ_C.callFunction(callFunctionKey,
				staticFunctionMapA_IDUQ_C, output, NE);
	}

	public static void doO_VECS_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapO_VECS_E staticFunctionMapO_VECS_C,
			IMV_SIQ output, App NE) throws InterruptedException, IOException {
		StaticReflectionMapO_VECS_C.callFunction(callFunctionKey,
				staticFunctionMapO_VECS_C, output, NE);
	}

	public static void doO_IDUQ_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapO_IDUQ_E staticFunctionMapO_IDUQ_C,
			IMV_SIQ output, App NE) {
		StaticReflectionMapO_IDUQ_C.callFunction(callFunctionKey,
				staticFunctionMapO_IDUQ_C, output, NE);
	}

	public static void doP_VECS_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapP_VECS_E staticFunctionMapP_VECS_C,
			IMV_SIQ output, App NE) {
		StaticReflectionMapP_VECS_C.callFunction(callFunctionKey,
				staticFunctionMapP_VECS_C, output, NE);
	}

	public static void doP_IDUQ_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapP_IDUQ_E staticFunctionMapP_IDUQ_C,
			IMV_SIQ output, App NE) {
		StaticReflectionMapP_IDUQ_C.callFunction(callFunctionKey,
				staticFunctionMapP_IDUQ_C, output, NE);
	}

	public static void doM_VECS_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapM_VECS_E staticFunctionMapM_VECS_C,
			IMV_SIQ output, App NE) {
		StaticReflectionMapM_VECS_C.callFunction(callFunctionKey,
				staticFunctionMapM_VECS_C, output, NE);
	}

	public static void doM_IDUQ_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapM_IDUQ_E staticFunctionMapM_IDUQ_C,
			IMV_SIQ output, App NE) {
		StaticReflectionMapM_IDUQ_C.callFunction(callFunctionKey,
				staticFunctionMapM_IDUQ_C, output, NE);
	}

	public static void doV_AOPM_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapV_AOPM_E staticFunctionMapV_AOPM_C,
			IMV_SIQ output, App NE) {
		StaticReflectionMapV_AOPM_C.callFunction(callFunctionKey,
				staticFunctionMapV_AOPM_C, output, NE);
	}

	public static void doV_IDUQ_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapV_IDUQ_E staticFunctionMapV_IDUQ_C,
			IMV_SIQ output, App NE) {
		StaticReflectionMapV_IDUQ_C.callFunction(callFunctionKey,
				staticFunctionMapV_IDUQ_C, output, NE);
	}

	public static void doE_AOPM_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapE_AOPM_E staticFunctionMapE_AOPM_C,
			IMV_SIQ output, App NE) {
		StaticReflectionMapE_AOPM_C.callFunction(callFunctionKey,
				staticFunctionMapE_AOPM_C, output, NE);
	}

	public static void doE_IDUQ_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapE_IDUQ_E staticFunctionMapE_IDUQ_C,
			IMV_SIQ output, App NE) {
		StaticReflectionMapE_IDUQ_C.callFunction(callFunctionKey,
				staticFunctionMapE_IDUQ_C, output, NE);
	}

	public static void doC_AOPM_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapC_AOPM_E staticFunctionMapC_AOPM_C,
			IMV_SIQ output, App NE) throws InterruptedException, IOException {
		StaticReflectionMapC_AOPM_C.callFunction(callFunctionKey,
				staticFunctionMapC_AOPM_C, output, NE);
	}

	public static void doC_IDUQ_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapC_IDUQ_E staticFunctionMapC_IDUQ_C,
			IMV_SIQ output, App NE) {
		StaticReflectionMapC_IDUQ_C.callFunction(callFunctionKey,
				staticFunctionMapC_IDUQ_C, output, NE);
	}

	public static void doS_AOPM_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapS_AOPM_E staticFunctionMapS_AOPM_C,
			IMV_SIQ output, App NE) {
		StaticReflectionMapS_AOPM_C.callFunction(callFunctionKey,
				staticFunctionMapS_AOPM_C, output, NE);
	}

	public static void doS_IDUQ_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapS_IDUQ_E staticFunctionMapS_IDUQ_C,
			IMV_SIQ output, App NE) {
		StaticReflectionMapS_IDUQ_C.callFunction(callFunctionKey,
				staticFunctionMapS_IDUQ_C, output, NE);
	}

	public static void doI_AOPM_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapI_AOPM_E staticFunctionMapI_AOPM_C,
			IMV_SIQ output, App NE) {
		StaticReflectionMapI_AOPM_C.callFunction(callFunctionKey,
				staticFunctionMapI_AOPM_C, output, NE);
	}

	public static void doI_VECS_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapI_VECS_E staticFunctionMapI_VECS_C,
			IMV_SIQ output, App NE) {
		StaticReflectionMapI_VECS_C.callFunction(callFunctionKey,
				staticFunctionMapI_VECS_C, output, NE);
	}

	public static void doD_AOPM_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapD_AOPM_E staticFunctionMapD_AOPM_C,
			IMV_SIQ output, App NE) {
		StaticReflectionMapD_AOPM_C.callFunction(callFunctionKey,
				staticFunctionMapD_AOPM_C, output, NE);
	}

	public static void doD_VECS_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapD_VECS_E staticFunctionMapD_VECS_C,
			IMV_SIQ output, App NE) {
		StaticReflectionMapD_VECS_C.callFunction(callFunctionKey,
				staticFunctionMapD_VECS_C, output, NE);
	}

	public static void doU_AOPM_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapU_AOPM_E staticFunctionMapU_AOPM_C,
			IMV_SIQ output, App NE) {
		StaticReflectionMapU_AOPM_C.callFunction(callFunctionKey,
				staticFunctionMapU_AOPM_C, output, NE);
	}

	public static void doU_VECS_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapU_VECS_E staticFunctionMapU_VECS_C,
			IMV_SIQ output, App NE) {
		StaticReflectionMapU_VECS_C.callFunction(callFunctionKey,
				staticFunctionMapU_VECS_C, output, NE);
	}

	public static void doQ_AOPM_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapQ_AOPM_E staticFunctionMapQ_AOPM_C,
			IMV_SIQ output, App NE) {
		StaticReflectionMapQ_AOPM_C.callFunction(callFunctionKey,
				staticFunctionMapQ_AOPM_C, output, NE);
	}

	public static void doQ_VECS_CaseFunction(CallFunctionKey callFunctionKey,
			String string, StaticFunctionMapQ_VECS_E staticFunctionMapQ_VECS_C,
			IMV_SIQ output, App NE) {
		StaticReflectionMapQ_VECS_C.callFunction(callFunctionKey,
				staticFunctionMapQ_VECS_C, output, NE);
	}

	// 中间传参的过程是前面的 interfaceReturn要变成传参因子数据, 而接口只识别传参因子变量名和
	// 传参map,
	// 这时候返回值的替换 传参map, 和传参因子的改变出现了, 我要做的就是添加 新的return因子,

	@SuppressWarnings("unchecked")
	public static IMV_SIQ preValues(IMV_SIQ output, String[] 传参因子) {
		boolean find = false;
		IMV_SIQ inputValues = null;
		// 取值方法, 先检查上一个接口
		if (null != output.get("lastInterfaceBackfeed")) {
			if (output.get("lastInterfaceBackfeed").toString()
					.equalsIgnoreCase("success")) {
				String lastInterfaceReturn = (String) output
						.get("lastInterfaceName");// 取 上一次运行接口名
				if (null != lastInterfaceReturn) {
					IMV_SIQ lastReturns = (IMV_SIQ) output
							.get(lastInterfaceReturn);
					// 取上一次运行接口的返回结果。
					// inputValues= (IMV_SIQ)
					// lastReturns.get("interfaceReturn");//
					// 因为java的return是唯一值, 所以很好确定位置为第一个
					inputValues = new IMV_SIQ();
					inputValues.put(传参因子[0],
							lastReturns.get("interfaceReturn"));
					find = true;
				}
			}
		}
		// 检查上一个接口是否匹配;
		if (find) {
			// if(inputValues.containsKey("score")&&
			// inputValues.containsKey("nameScore")) {
			// find= true;
			// }else {
			// find= false;
			// }
			for (int i = 0; i < 传参因子.length; i++) {// 轮训传参 string i++
				if (!inputValues.containsKey(传参因子[i])) {// 可以不要，谨慎度低，要，活力低//还是保留。
					find = false;
				}
			}
		}
		//////////////////////////////////////////////////////////////////////////////////////
		// 操作方法, 就检查全局传参
		if (!find) {// 当上一个接口没有返回这个接口需要的数据时, 就检查全局传参
			inputValues = (IMV_SIQ) output.get("inputValues");// 取存储值
		}
		// 检查特定输入参数是否匹配
		if (null != inputValues) {
			// if(inputValues.containsKey("score")&&
			// inputValues.containsKey("nameScore")) {
			// find= true;
			// }
			find = true;
			for (int i = 0; i < 传参因子.length; i++) {// 轮训传参 string i++
				if (!inputValues.containsKey(传参因子[i])) {//
					find = false;
				}
			}
			// map缓存时间过久就要遗忘。
		} // 本来想设计成插件模式, 但是速度降低100倍不止, 先不考虑,
		  /////////////////////////////////////////////////////////////////////////////////////////////////
		inputValues.put("find", find);
		return inputValues;
	}

	// 之前变动中英文编码 和 中药分离出系统 和 元基花走孢子模式优化，导致这类参数null 变成全局null的问题。
	public static void postValues(IMV_SIQ output, boolean find, Object map,
			String callFunctionKey) {
		if (find) {
			IMV_SIQ returnValue = new IMV_SIQ();
			returnValue.put("feedback", "object");
			if (null == map) {
				returnValue.put("feedback", "null");
			}
			// 存储方法
			map = null == map ? new IMV_SIQ() : map;// later all in 1
			returnValue.put("interfaceReturn", map);// later interfaceReturn
													// will cause a tinshell
													// probs
			// 输出
			output.put(callFunctionKey, returnValue);
			output.put("lastInterfaceName", callFunctionKey);// 稍后设计成可
															 // 理论完美并行的模式。
			output.put("lastInterfaceBackfeed", "success");

		} else {
			output.put("lastInterfaceName", callFunctionKey);
			output.put("lastInterfaceBackfeed", "faild");
		}
	}

	// 像神一样思考
	public static String[] callAnnotationMap(String chromosome,
			String callFunctionKey) {
		if (chromosome.equalsIgnoreCase("A_VECS")) {
			return StaticFunctionMapA_VECS_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		if (chromosome.equalsIgnoreCase("A_IDUQ")) {
			return StaticFunctionMapA_IDUQ_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		if (chromosome.equalsIgnoreCase("O_VECS")) {
			return StaticFunctionMapO_VECS_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		if (chromosome.equalsIgnoreCase("O_IDUQ")) {
			return StaticFunctionMapO_IDUQ_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		if (chromosome.equalsIgnoreCase("P_VECS")) {
			return StaticFunctionMapP_VECS_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		if (chromosome.equalsIgnoreCase("P_IDUQ")) {
			return StaticFunctionMapP_IDUQ_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		if (chromosome.equalsIgnoreCase("M_VECS")) {
			return StaticFunctionMapM_VECS_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		if (chromosome.equalsIgnoreCase("M_IDUQ")) {
			return StaticFunctionMapM_IDUQ_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		if (chromosome.equalsIgnoreCase("I_AOPM")) {
			return StaticFunctionMapI_AOPM_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		if (chromosome.equalsIgnoreCase("I_VECS")) {
			return StaticFunctionMapI_VECS_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		if (chromosome.equalsIgnoreCase("D_AOPM")) {
			return StaticFunctionMapD_AOPM_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		if (chromosome.equalsIgnoreCase("D_VECS")) {
			return StaticFunctionMapD_VECS_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		if (chromosome.equalsIgnoreCase("U_AOPM")) {
			return StaticFunctionMapU_AOPM_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		if (chromosome.equalsIgnoreCase("U_VECS")) {
			return StaticFunctionMapU_VECS_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		if (chromosome.equalsIgnoreCase("Q_AOPM")) {
			return StaticFunctionMapQ_AOPM_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		if (chromosome.equalsIgnoreCase("Q_VECS")) {
			return StaticFunctionMapQ_VECS_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		if (chromosome.equalsIgnoreCase("V_AOPM")) {
			return StaticFunctionMapV_AOPM_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		if (chromosome.equalsIgnoreCase("V_IDUQ")) {
			return StaticFunctionMapV_IDUQ_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		if (chromosome.equalsIgnoreCase("E_AOPM")) {
			return StaticFunctionMapE_AOPM_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		if (chromosome.equalsIgnoreCase("E_IDUQ")) {
			return StaticFunctionMapE_IDUQ_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		if (chromosome.equalsIgnoreCase("C_AOPM")) {
			return StaticFunctionMapC_AOPM_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		if (chromosome.equalsIgnoreCase("C_IDUQ")) {
			return StaticFunctionMapC_IDUQ_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		if (chromosome.equalsIgnoreCase("S_AOPM")) {
			return StaticFunctionMapS_AOPM_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		if (chromosome.equalsIgnoreCase("S_IDUQ")) {
			return StaticFunctionMapS_IDUQ_C.annotationMap
					.getString(callFunctionKey).split(":");
		}
		return null;
	}
}
//153
//		if(callFunctionKey.contains("main")) {//稍后分出去
//			//写法1
//			//case 参数
//			if(string.contains("null")) {
//				//其他参数可用object, json 都可以
//				staticFunctionMapU_VECS_C.main(null);//稍后分出去
//				output.put("U_VECS_main", "void");//非void接口就直接put进去即可。
//			}
//			//写法2
//			//可以插件遍历, 可以 接口遍历, 可以web的outowire 遍历,
//			//无数种方法遍历
//		}

//写法2
//我准备设计一种callFunctionKey对应的接口call模式
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    <link rel="icon" href="../images/logo/logo.png" type="image/x-icon">
    <link rel="shortcut icon" href="../images/logo/logo.png"
          type="image/x-icon">
    <title>浏阳德塔软件开发有限公司 女娲计划</title>
</head>
<body style="Max-width: 700px; text-align:center; margin:auto;">
<div style="text-align:left; Max-width: 680px; margin-left:15px;">
    <a href="../">上一页</a>
    <br/>
    <br/>
    <br/>第七章 类人DNA与神经元基于催化算子映射编码方式
    <br/>The Initons Catalytic Reflection Between Humanoid DNA and Nero
    Cell
    <br/>类人 DNA 与 神经元基于催化算子映射编码方式
    <br/>Yaoguang Luo, Rongwu Luo
    <br/>罗瑶光, 罗荣武
    <br/>Keywords
    <br/>VPCS, AOPM, IDUC, Nero, Artificial, Decoder, Medical, Paralling,
    Computing,
    <br/>Humanoid, ETL, Parser, Data Mining
    <br/>关键词
    <br/>VPCS 架构 AOPM 逻辑 IDUC 编码 神经元 人工 解码 医学 并行计算 类人仿生 ETL
    数据挖掘 爬取
    <br/>6 IDUC DNA and Its Applications, IDUC DNA与它的应用
    <br/>
    <br/>These were all the later stories. The application was too wide.
    First of all, my ETL began to expand in the three-dimensional direction
    to better serve medicine. Secondly, virus immunology and immortal virus
    exploration will never stop. Why ETL was used as the expansion point is
    inspired by my OSGI paper on October 17, 2013. It was as follows.
    <br/>这些都是后话. 应用面太广泛了, 首先, 我的 ETL 开始往 3 维方向拓展更好的为医学服务.
    其次, 病毒免疫学和 永生病毒 探索, 永不停歇. 为什么采用 ETL 来作为拓展点, 灵感来自于我
    2013 年 10 月 17 日一篇 OSGI 的感想论文.
    如下论证作品: 人工智能的达尔文进化思想 (The Darwin's Theory of The Artificial
    Intelligence)
    <br/>
    <br/>
    In the latest knowledge of engineering structure, the
    traditional expert system occupies a dominant position, but the world's
    demand system is in a changeable operating environment, so the data
    persistence theory is a goal to strive for. Artificial intelligence
    software, too, can't escape the disadvantages brought by natural
    updating. Where artificial intelligence will go, It will be planned
    naturally. Just like ‘Darwin's theory of biological evolution’, the new
    intelligent system standards are naturally selected by needs, which is
    the central idea I want to express. In the past 50 years, some classic
    software can't escape the choice of demand, and finally It turns yellow
    and dim. Of course, some enterprises rewrite and upgrade their products
    desperately. Because of the aging of core developers, new reformers
    can't master the original development ideas and theories. Finally, the
    quality of products suffers a huge impact and suffers heavy losses. A
    new software development theory needs to be confirmed, which is my
    thought. Software, too, needs an evolutionary system with
    self-artificial selection.
    <br/>
    最新的知识工程结构中, 传统的专家系统占据着主导的地位, 可是世界的需求体系处在一个多变的
    运行环境, 所以数据持久化理论是一个为之奋斗的目标. 人工智能软件也一样, 逃避不了自然的
    更新所带来的种种弊端. 人工智能何去何从, 自然会规划它, 正如达尔文的生物进化论一样, 新
    的智能体系标准都是被需求自然选择出来, 这就是我要表达的中心思想. 过去 50 年里, 一些
    经典的软件逃不过需求的抉择, 最终枯黄暗淡, 当然一些企业将产品拼命的重写升级, 因为核心
    开发者的年龄老化, 新的改造者无法掌握原始开发思想和理论, 最后产品的品质遭受巨大的冲击,
    损失惨重, 一种新的软件开发理论需要被人所证实, 这也就是我的思想. 软件也一样, 需要有
    自我的人工选择的进化体系.
    <br/>
    <br/>
    Through the recent construction, design and coding test of
    Unicorn AI software, I found that many computer theories created by
    fantasy have great differences, in actual programming analysis. I used
    JAVA-based language, and I found that the inheritance of JAVA did not
    meet the language standard with evolutionary thought, but Its
    methodology in this initial evolutionary standard test was far superior
    to C/C++. I didn't bring any troubles to my actual programming when I
    wrote JAVA program in C style, but JAVA still needs to be improved. For
    example, you abstract a parent class, and the variable function of your
    subclass still needs to be written in the way of "Object parent class=
    (subclass) parent class" to make subclass operation. If grandchildren
    inherit subclasses, how can Object get grandchildren? (I use the Object
    subclass to inherit the parent class, and then the Object subclass =
    (grandson) subclass. In this way, the grandchildren get the operation),
    but this is a big problem of dynamic memory structure allocation! The
    design is rather cumbersome. JAVA still stays at the level of primary
    language evolution, and does not have advanced evolutionary ideas.
    Secondly, if a subclass has more than one grandchild, only the subclass
    can operate, and the parent class cannot operate accordingly. This is
    also a criticism. Is It realized by adding Object subclass = (grandson)
    subclass and Object parent class = (subclass) parent class? This is
    even more complicated.
    <br/>
    通过最近的 Unicorn AI 软件的构造, 设计和编码测试中, 我发现了许多因空想而创造的计算机
    理论在实际的编程分析中有巨大的差异, 我用的是 JAVA 为主的语言, 我就发现 JAVA 的继承
    没有达到具有进化思想的语言标准, 但是 JAVA 在这个初期的进化标准测试中其方法论远远胜出
    C/C++, 我用 C 风格写 JAVA 程序并没有给我的实际编程带来种种麻烦, 但是 JAVA 仍然需要
    改进, 比如你抽象了一个父类, 而你的子类的变量函数还是需要在“Object 父类=(子类)父类”
    这样的写法中的才能做出子类运算. 如果孙类又继承子类, 怎么让 Object 得到孙类？(我的用
    的是 Object 子类继承父类, 然后 Object 子类=(孙类)子类. 这样孙类得到了运算), 可是
    这就是一个动态内存结构分配的大问题! 设计的相当繁琐. JAVA 还停留在初级语言进化级别,
    没有具备高级的进化思想. 其次, 子类如果有多个孙类, 也只有子类可以运算, 父类就被无法作出
    相应的运算. 这也是一个诟病, 难道再加上Object 子类=(孙类)子类, Object 父类=(子类)父类
    来实现？这就更加繁琐了.
    <br/>
    <br/>
    Through the above description, I have my own views, but I still
    chose JAVA, even though it is cumbersome, but there is no mistake,
    because it will be more cumbersome to implement in the underlying
    language. There are more traps. It is a natural choice for artificial
    intelligence to choose JAVA. JAVA and C# are both high-level languages,
    but JAVA's personality is born to deal with data, because JAVA was a
    WEB language in Its early days, and WEB has unique advantages in
    dealing with data information, which is a real example of JAVA evolving
    into a data analysis language. C# has been improving itself in this
    problem, just like JAVA, even like JAVA, but there is no system to
    evaluate it. The WEB data engineers who applied JAVA in the early days
    will not transfer to C#, so the biggest advantage of C# is that it is
    only applied to controls on WINDOWS.
    <br/>
    通过上面的描述, 我有自己的看法, 可是我还是选择了 JAVA, 即使繁琐, 但是没有任何错误,
    因为用底层语言来实现就会更加繁琐. 陷阱更多. 人工智能选择了 JAVA 是一个自然的抉择. JAVA
    和 C#都是高层语言, 可是 JAVA 的个性就是天生对数据来处理的, 因为 JAVA 早期是一个
    WEB 语言, WEB 处理数据信息有独特的优势, 这是 JAVA 进化为数据分析语言的一个真实的例子
    . C#在这个问题里一直在改进自己, 类似 JAVA 一样, 甚至和 JAVA 一样, 可是没有一个
    体系来评估它. 早期应用 JAVA 的 WEB 数据工程师也不会转移到 C#. 所以 C#的最大优势
    还是仅仅在WINDOWS 上的控件应用.
    <br/>
    <br/>Through this description, it only proves that the greatest
    advantage of any language is only reflected in Its creative theory and
    thought at the beginning of Its birth. Therefore, JAVA and C# are not
    comparable at all. Because their original creative theory, system and
    ideological structure are different. If JAVA and C# really fail,
    finally, through the prediction of evolutionary thought, JAVA will go
    in the direction of graphics, big data analysis, WEB and C# should go
    in the direction of interface, control and WINDOWS device integration.
    The evolution of artificial intelligence software is mainly divided
    into update of parent class, variation and inheritance of subclass.
    <br/>
    通过这段的描述, 仅仅证明任何一种语言的最大优势也仅仅体现在它诞生之初的创造理论和思想.
    所以 JAVA和 C#根本就没有什么可比性. 因为他们最原始的创造理论, 体系和思想结构就不一样.
    如果真的 JAVA 和 C#不倒, 最后, 通过进化的思想预测, JAVA 最后走图形, 大数据分析,
    WEB, 方向, 而 C# 应该走界面, 控件, WINDOWS 设备集成方向. 人工智能软件的进化主要
    分为父类的更新, 子类的变异和继承.
    <br/>
    <br/>
    JAVA is perfect for dealing with subclass functions, and people
    who have used JAVA to develop large projects are quite experienced in
    dealing with interfaces and inheritance. But is there any variation in
    JAVA? It can be said that there is no, for example, when the parent
    class public attribute 1 = 0; Subclasses can't have the public
    attribute 1= 1, which is a mutational failure problem. JAVA is more
    flexible, but not as flexible as scripting language. Secondly, I want
    to say that the variation of JAVA is a variation with quotation marks.
    Its characteristic is that subclasses modify the functions of the
    parent class, and subclasses of JAVA can modify the processing
    procedure of functions with the same name of the parent class. However,
    you have to make the subclass and the parent class have the same
    function names. This is a JAVA default mechanism, which executes the
    same name of the parent class first, and then executes the same name of
    the subclass. Then return to the parent class, and then return to the
    procedure of. Therefore, the function with the same name can be
    modified in subclasses, thus ensuring parameter variation. In this way,
    the software is also very flexible and unique in the actual writing
    process. Finally, I have a deep experience through the expression of
    language evolution thought and program evolution thought mentioned
    above. Every language needs Its needs if It is to be deeply rooted, and
    Its functions shall be selectively evolved in the needs. Otherwise,
    this is the biggest reason why languages have been eliminated. I don't
    like to see various languages emerge one after another in today's
    world. This is the biggest criticism that many languages have not
    evolved and can't reflect their needs. Secondly, languages need to be
    extended, and the appearance of API class libraries and some
    architecture systems of high-level languages is a good proof of
    extension. Finally, variation is similar to scripting language, which
    is flexible and convenient.
    <br/>
    <br/>JAVA 处理子类函数是比较完美的, 用过 JAVA 开发大型项目的人都相当有经验处理
    接口和继承. 可是 JAVA 有没有变异的特性呢？可以说无, 比如我举个例子, 当父类 Public
    属性 1=0;, 子类就无法在 Public 属性 1=1 了, 这就是一个变异失效的问题. JAVA
    很灵活, 但是不够脚本语言灵活. 其次我要说的是 JAVA 的变异是带引号的变异, 其特点就是
    子类修改父类函数, JAVA 的子类是可以修改父类的同名函数处理过程的. 不过你要让子类和
    父类的函数名一样, 这是一个 JAVA 默认的机制, 先执行父类同名, 再执行子类同名. 然后
    返回到父类, 然后返回的过程. 所以同名函数可以在子类里得到修改, 保证了参数变异. 这样,
    软件在实际的编写过程中也非常的灵活和独到. 最后通过上述的语言进化思想, 程序进化思想的表述,
    我有一个很深的体会. 每一种语言要根深蒂固, 需要 有它的需求, 它的功能在需求中要有选择
    地得到进化. 不然, 这就是语言被淘汰的最大原因, 我不喜欢看到当今世界上各种语言层出不穷
    , 这就是许多语言没有得到进化, 体现不了需求的最大诟病. 其次, 语言需要扩展, 高级语言
    的 API 类库和一些架构体系的出现是一个很好的扩展证明. 最后是变异, 类似脚本语言,
    灵活, 方便.
    <br/>
    What about software? The same is true for software. It is
    particularly important to choose a language that suits your own needs.
    Secondly, the architecture of the software shall have loose coupling,
    which is similar to OSGI and Felix. The OSGI idea of KNIME is
    consistent with that of LIFERAY. Although the API design style is
    different, the effect is very thick. Biology needs Darwin's thought,
    and artificial intelligence also exists, which is the basis of demand
    persistence. This is also the basic condition for my research and
    development of Unicorn AI platform.
    <br/>
    那么软件呢？软件也一样, 选择一门适应自己需求的语言来设计尤为重要. 其次, 软件的架构
    要有松耦度, 类似于 OSGI, FELIX 那样, 进行组件持久化, KNIME 的 OSGI 思想和
    LIFERAY 的 OSGI 思想是一致的, 虽然 API 设计风格不一样, 但是效果都很笃厚. 生物
    需要有达尔文思想, 人工智能同样也存在, 这是需求持久化的基础. 这也是我研发 Unicorn AI
    平台的基本条件.
    <br/>
    <br/>
    Now I have enough confidence to continue to focus on the
    argument of making ETL mapped by my DNA code with evolutionary system
    reuse the perfect guarantee requirement persistence. On how to use ETL
    to map the code, I will go back to the previous year again and analyze
    the design idea of this picture at that time as follows
    <br/>
    现在我有足够信心持续专注在让我的带进化系统的 DNA 编码所映射的ETL 重用 完美的保障
    需求持久化 论点. 关于怎么用 ETL 来映射编码, 我会再次回到前年, 分析当时这张图片的
    设计思路如下:
    <img class="banner_img" style="width: 100%" src="../images/5_7108/7/7_33.jpg"
         alt="浏阳德塔软件开发有限公司,罗瑶光"/>
    <br/>
    <br/>Yes, I have an idea already!! Exciting, ETL node
    three-dimensional classification. This vocabulary
    <br/>是的我已经有想法了!! 令人兴奋, ETL 节点 三维分类. 这个词汇.
    <br/>
</div>
</body>